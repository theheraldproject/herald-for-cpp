//  Copyright 2021 Herald Project Contributors
//  SPDX-License-Identifier: Apache-2.0
//

#ifndef HERALD_RISK_MANAGER_H
#define HERALD_RISK_MANAGER_H

#include "../datatype/risk_score.h"

/**
 * /brief A Risk Manager takes runtime (not compile time) configuration to continuously
 * manage risk scores generated by a set of available (at compile time) algorithms. It also
 * manages notifications (at an API level) of when thresholds have been breached.
 */
template <std::size_t MaxAlgorithmInstances, typename RiskStoreT, typename... AlgorithmT>
// TODO ensure AlgorithmT meets our requirements, and give a sensible error message if not
class RiskManager {
public:
  static constexpr std::size_t Size = MaxAlgorithmInstances;
  static constexpr std::size_t AlgorithmCount = sizeof...(AlgorithmT);

  RiskManager() noexcept;
  ~RiskManager() noexcept;

  /// MARK: Configuration settings for the Risk Manager
  // QN: SHOULD THIS BE IN THE STORE RATHER THAN HERE???
  void setSummaryRetentionPeriod(const TimeInterval duration) noexcept;
  const TimeInterval getSummaryRetentionPeriod() const noexcept;

  void setScoringPeriod(const TimeInterval duration) noexcept;
  const TimeInterval getScoringPeriod() const noexcept;

  /// MARK: Algorithm configuration

  // Add configuration for an algorithm to run
  // Remove configuration (not associated scores) for an algorithm

  // NOTE: It's possible to have algorithms that are not 'currently' running (continuously), so don't proactively remove old scores

  // Remove scores for a removed algorithm

  /// MARK: Manual Operational methods

  /** /brief Rerun all risk scores for a given time period, e.g. when underlying risk config has changed **/
  void rerunForAgent(const UUID& agentId, const Date& from, const Date& to) noexcept;

  /// MARK: Event driven operational methods
  template <typename ExposureManagerT>
  void observeExposureManager(const ExposureManagerT& mgr) noexcept;

  template <typename ExposureManagerT>
  void ceaseObservingExposureManager(const ExposureManagerT& mgr) noexcept;

private:
  // Hold an instance of each algorithm
  std::array<std::variant<AlgorithmT...>,AlgorithmCount> algorithms;
  // Hold up to Size numbers of configurations, and links to their related algorithms (via instanceId)
  std::array<AlgorithmConfig, Size> configurations;
};

#endif